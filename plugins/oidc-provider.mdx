---
title: OIDC Provider
description: Turn your application into an OAuth 2.0 and OpenID Connect provider
---

The OIDC Provider plugin transforms your Better Auth instance into a fully functional OAuth 2.0 and OpenID Connect (OIDC) provider. This allows other applications to authenticate users through your platform.

## Use Cases

- Build a centralized authentication service for multiple applications
- Enable single sign-on (SSO) across your product suite
- Provide OAuth/OIDC authentication for third-party integrations
- Create a white-label authentication solution
- Implement authorization servers for microservices

## Installation

The OIDC Provider plugin is included in the Better Auth core package.

```bash
pnpm add better-auth
```

## Database Schema

The plugin requires additional database tables. Run the migration:

```bash
pnpm better-auth migrate
```

This creates the following tables:
- `oauthApplication` - OAuth clients/applications
- `oauthAccessToken` - Issued access and refresh tokens
- `oauthConsent` - User consent records

## Configuration

### Basic Setup

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    oidcProvider({
      // Optional: use JWT plugin for RS256/EdDSA signing
      useJWTPlugin: false,
      
      // Optional: trusted clients (for testing)
      trustedClients: [
        {
          clientId: "test-client",
          clientSecret: "test-secret",
          redirectUrls: ["http://localhost:3000/callback"],
        },
      ],
    }),
  ],
});
```

### With JWT Plugin (Recommended for Production)

```ts title="auth.ts"
import { betterAuth } from "better-auth";
import { oidcProvider, jwt } from "better-auth/plugins";

export const auth = betterAuth({
  plugins: [
    jwt({
      jwks: {
        keyPairs: [
          {
            kid: "main",
            alg: "RS256",
            privateKey: process.env.PRIVATE_KEY!,
            publicKey: process.env.PUBLIC_KEY!,
          },
        ],
      },
    }),
    oidcProvider({
      useJWTPlugin: true, // Use RS256 signing from JWT plugin
    }),
  ],
});
```

## Configuration Options

<Properties>
  <Property name="useJWTPlugin" type="boolean" default="false">
    Use the JWT plugin for ID token signing. When enabled, uses RS256/EdDSA from JWKS. When disabled, uses HS256 with client secret.
  </Property>
  <Property name="trustedClients" type="Client[]" default="[]">
    Array of trusted OAuth clients that bypass database lookups. Useful for testing and internal services.
  </Property>
  <Property name="scopes" type="string[]" default="['openid', 'profile', 'email', 'offline_access']">
    Additional scopes supported beyond the defaults.
  </Property>
  <Property name="codeExpiresIn" type="number" default="600">
    Authorization code expiration time in seconds (default: 10 minutes).
  </Property>
  <Property name="accessTokenExpiresIn" type="number" default="3600">
    Access token expiration time in seconds (default: 1 hour).
  </Property>
  <Property name="refreshTokenExpiresIn" type="number" default="604800">
    Refresh token expiration time in seconds (default: 7 days).
  </Property>
  <Property name="allowPlainCodeChallengeMethod" type="boolean" default="true">
    Allow the `plain` code challenge method for PKCE. Set to `false` to require S256.
  </Property>
  <Property name="requirePKCE" type="boolean" default="false">
    Require PKCE for all authorization requests.
  </Property>
  <Property name="storeClientSecret" type="'plain' | 'encrypted' | 'hashed' | object" default="'plain'">
    How to store client secrets:
    - `'plain'`: Store as-is
    - `'encrypted'`: Encrypt with auth secret
    - `'hashed'`: Hash with bcrypt
    - Custom object with `hash`/`decrypt` methods
  </Property>
  <Property name="allowDynamicClientRegistration" type="boolean" default="false">
    Allow unauthenticated client registration via RFC 7591.
  </Property>
  <Property name="generateClientId" type="() => string">
    Custom function to generate client IDs.
  </Property>
  <Property name="generateClientSecret" type="() => string">
    Custom function to generate client secrets.
  </Property>
  <Property name="getAdditionalUserInfoClaim" type="(user, scopes, client) => Promise<object>">
    Add custom claims to ID tokens and userinfo responses.
  </Property>
</Properties>

## Setup Steps

### 1. Register an OAuth Application

#### Via API

```ts title="app/api/oauth/register/route.ts"
import { auth } from "@/lib/auth";

export async function POST(request: Request) {
  const body = await request.json();
  
  const result = await auth.api.registerOAuthApplication({
    body: {
      redirect_uris: ["http://localhost:3001/callback"],
      client_name: "My App",
      logo_uri: "https://example.com/logo.png",
      client_uri: "https://example.com",
    },
    headers: request.headers,
  });
  
  return Response.json(result);
}
```

#### Via Database

```sql
INSERT INTO oauth_application (
  client_id,
  client_secret,
  name,
  redirect_urls,
  type,
  authentication_scheme,
  disabled
) VALUES (
  'my-client-id',
  'my-client-secret',
  'My Application',
  'http://localhost:3001/callback',
  'web',
  'client_secret_basic',
  false
);
```

### 2. Implement Authorization Flow

The OIDC provider supports the **authorization code flow** with optional PKCE.

#### Authorization Request

```
GET https://your-app.com/api/auth/oauth2/authorize?
  response_type=code
  &client_id=my-client-id
  &redirect_uri=http://localhost:3001/callback
  &scope=openid profile email
  &state=random-state
  &code_challenge=challenge
  &code_challenge_method=S256
```

#### Token Exchange

```bash
curl -X POST https://your-app.com/api/auth/oauth2/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=authorization_code" \
  -d "code=authorization_code" \
  -d "redirect_uri=http://localhost:3001/callback" \
  -d "client_id=my-client-id" \
  -d "client_secret=my-client-secret" \
  -d "code_verifier=verifier"
```

#### Refresh Token

```bash
curl -X POST https://your-app.com/api/auth/oauth2/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=refresh_token" \
  -d "refresh_token=refresh_token" \
  -d "client_id=my-client-id" \
  -d "client_secret=my-client-secret"
```

### 3. Access User Info

```bash
curl https://your-app.com/api/auth/oauth2/userinfo \
  -H "Authorization: Bearer access_token"
```

Response:

```json
{
  "sub": "user-id",
  "email": "user@example.com",
  "email_verified": true,
  "name": "John Doe",
  "picture": "https://example.com/avatar.jpg",
  "given_name": "John",
  "family_name": "Doe"
}
```

## OIDC Protocol Details

### Discovery Endpoint

The plugin exposes an OIDC discovery endpoint:

```
GET /.well-known/openid-configuration
```

Response:

```json
{
  "issuer": "https://your-app.com",
  "authorization_endpoint": "https://your-app.com/api/auth/oauth2/authorize",
  "token_endpoint": "https://your-app.com/api/auth/oauth2/token",
  "userinfo_endpoint": "https://your-app.com/api/auth/oauth2/userinfo",
  "jwks_uri": "https://your-app.com/api/auth/jwks",
  "registration_endpoint": "https://your-app.com/api/auth/oauth2/register",
  "end_session_endpoint": "https://your-app.com/api/auth/oauth2/endsession",
  "scopes_supported": ["openid", "profile", "email", "offline_access"],
  "response_types_supported": ["code"],
  "grant_types_supported": ["authorization_code", "refresh_token"],
  "subject_types_supported": ["public"],
  "id_token_signing_alg_values_supported": ["RS256", "EdDSA", "none"],
  "token_endpoint_auth_methods_supported": [
    "client_secret_basic",
    "client_secret_post",
    "none"
  ],
  "code_challenge_methods_supported": ["S256"]
}
```

### Supported Scopes

- `openid` - Required for OIDC; includes `sub` claim
- `profile` - Returns `name`, `given_name`, `family_name`, `picture`
- `email` - Returns `email` and `email_verified`
- `offline_access` - Issues refresh tokens

### ID Token Structure

```json
{
  "sub": "user-id",
  "aud": "client-id",
  "iss": "https://your-app.com",
  "iat": 1234567890,
  "exp": 1234571490,
  "auth_time": 1234567890,
  "nonce": "random-nonce",
  "email": "user@example.com",
  "email_verified": true,
  "name": "John Doe",
  "picture": "https://example.com/avatar.jpg"
}
```

### RP-Initiated Logout

Implements [OpenID Connect RP-Initiated Logout 1.0](https://openid.net/specs/openid-connect-rpinitiated-1_0.html):

```
GET /oauth2/endsession?
  id_token_hint=id_token
  &post_logout_redirect_uri=https://client.example.com/logout
  &state=random-state
```

## Advanced Usage

### Custom User Claims

Add custom claims to ID tokens:

```ts
oidcProvider({
  getAdditionalUserInfoClaim: async (user, scopes, client) => {
    // Add custom claims based on scopes or client
    if (scopes.includes("admin")) {
      return {
        role: "admin",
        permissions: await getPermissions(user.id),
      };
    }
    return {};
  },
})
```

### Hashed Client Secrets

```ts
import bcrypt from "bcryptjs";

oidcProvider({
  storeClientSecret: {
    hash: async (secret) => {
      return bcrypt.hash(secret, 10);
    },
    verify: async (stored, provided) => {
      return bcrypt.compare(provided, stored);
    },
  },
})
```

### Public Clients (PKCE Required)

Register a public client (mobile/SPA):

```json
{
  "client_id": "mobile-app",
  "type": "public",
  "redirect_urls": ["myapp://callback"],
  "require_pkce": true
}
```

Public clients must use PKCE and don't have a client secret.

### Skip Consent for Trusted Clients

```ts
oidcProvider({
  trustedClients: [
    {
      clientId: "first-party-app",
      clientSecret: "secret",
      redirectUrls: ["https://app.example.com/callback"],
      skipConsent: true, // Skip consent screen
    },
  ],
})
```

## Security Considerations

### PKCE (Proof Key for Code Exchange)

PKCE prevents authorization code interception attacks. Enable for all clients:

```ts
oidcProvider({
  requirePKCE: true,
  allowPlainCodeChallengeMethod: false, // Require S256
})
```

### Client Secret Storage

Never store secrets in plain text for production:

```ts
oidcProvider({
  storeClientSecret: "hashed", // Use bcrypt hashing
})
```

### Token Expiration

Use short-lived access tokens and longer refresh tokens:

```ts
oidcProvider({
  accessTokenExpiresIn: 900, // 15 minutes
  refreshTokenExpiresIn: 2592000, // 30 days
  codeExpiresIn: 300, // 5 minutes
})
```

### Redirect URI Validation

Redirect URIs are strictly validated against registered values. Use exact matches:

```ts
// Good
redirectUrls: ["https://app.example.com/callback"]

// Avoid wildcards (not supported)
redirectUrls: ["https://*.example.com/callback"] // ‚ùå
```

### State Parameter

Always validate the `state` parameter to prevent CSRF attacks (automatically handled by the plugin).

## API Reference

### Endpoints

#### GET /.well-known/openid-configuration

OIDC discovery endpoint.

**Server:** `auth.api.getOpenIdConfig`

#### GET /oauth2/authorize

Authorization endpoint.

**Server:** `auth.api.oAuth2authorize`

#### POST /oauth2/consent

Consent endpoint (for explicit user consent).

**Server:** `auth.api.oAuthConsent`

#### POST /oauth2/token

Token endpoint.

**Server:** `auth.api.oAuth2token`

#### GET /oauth2/userinfo

User info endpoint.

**Server:** `auth.api.oAuth2userInfo`

#### POST /oauth2/register

Dynamic client registration (RFC 7591).

**Server:** `auth.api.registerOAuthApplication`

**Client:** `authClient.oauth2.register`

#### GET /oauth2/client/:id

Get OAuth client details.

**Server:** `auth.api.getOAuthClient`

#### GET/POST /oauth2/endsession

RP-Initiated Logout endpoint.

**Server:** `auth.api.endSession`

## Examples

### Next.js OAuth Client

```ts title="app/auth/callback/route.ts"
import { NextRequest } from "next/server";

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const code = searchParams.get("code");
  
  // Exchange code for tokens
  const response = await fetch("https://your-provider.com/api/auth/oauth2/token", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      grant_type: "authorization_code",
      code: code!,
      redirect_uri: "http://localhost:3001/auth/callback",
      client_id: process.env.CLIENT_ID!,
      client_secret: process.env.CLIENT_SECRET!,
    }),
  });
  
  const tokens = await response.json();
  // Store tokens and redirect
}
```

### React Native Client (PKCE)

```tsx
import * as Crypto from 'expo-crypto';
import * as WebBrowser from 'expo-web-browser';

async function signInWithOAuth() {
  // Generate PKCE challenge
  const codeVerifier = Crypto.randomUUID();
  const codeChallenge = await Crypto.digestStringAsync(
    Crypto.CryptoDigestAlgorithm.SHA256,
    codeVerifier,
    { encoding: Crypto.CryptoEncoding.BASE64 }
  );
  
  // Build authorization URL
  const authUrl = new URL('https://your-provider.com/api/auth/oauth2/authorize');
  authUrl.searchParams.set('client_id', 'mobile-app');
  authUrl.searchParams.set('redirect_uri', 'myapp://callback');
  authUrl.searchParams.set('response_type', 'code');
  authUrl.searchParams.set('scope', 'openid profile email');
  authUrl.searchParams.set('code_challenge', codeChallenge);
  authUrl.searchParams.set('code_challenge_method', 'S256');
  
  // Open browser
  const result = await WebBrowser.openAuthSessionAsync(
    authUrl.toString(),
    'myapp://callback'
  );
  
  if (result.type === 'success') {
    const code = new URL(result.url).searchParams.get('code');
    // Exchange code with codeVerifier
  }
}
```

## Related Plugins

- [Generic OAuth](/plugins/generic-oauth) - Add OAuth client support
- [JWT](/plugins/jwt) - JWT signing and verification
- [SSO](/plugins/sso) - Enterprise SSO integration
